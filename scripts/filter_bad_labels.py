#!/usr/bin/env python3
# Copyright 2024 (Author: Antigravity)
# Script lọc dữ liệu dựa trên WER giữa label gốc và hypothesis từ decode

import argparse
import logging
import ast
from pathlib import Path
from typing import Dict, Tuple

import jiwer
from lhotse import load_manifest_lazy, CutSet
from tqdm import tqdm

def get_args():
    parser = argparse.ArgumentParser(
        description="Filter a Lhotse manifest based on WER between original transcript and decoded hypothesis."
    )
    parser.add_argument(
        "--manifest-in",
        type=Path,
        required=True,
        help="Path to the input manifest (e.g., fbank/regions_63/vietASR_cuts_regions_63.jsonl.gz)",
    )
    parser.add_argument(
        "--decode-results",
        type=Path,
        required=True,
        help="Path to the decoding results file (recogs-*.txt). Generated by decode.py.",
    )
    parser.add_argument(
        "--manifest-out",
        type=Path,
        required=True,
        help="Path to save the filtered manifest.",
    )
    parser.add_argument(
        "--wer-threshold",
        type=float,
        default=0.5,
        help="WER threshold. Cuts with WER > threshold will be removed. Default: 0.5 (50%%)",
    )
    parser.add_argument(
        "--keep-unmatched",
        action="store_true",
        help="If True, keep cuts that are not found in the decode results file.",
    )
    parser.add_argument(
        "--inspect-num",
        type=int,
        default=0,
        help="Number of rejected examples to print for inspection. Default: 0",
    )
    return parser.parse_args()

def parse_recogs_file(path: Path) -> Dict[str, Tuple[str, str]]:
    """
    Parse recogs file với format:
    cut_id:\tref=['word1', 'word2', ...]
    cut_id:\thyp=['word1', 'word2', ...]
    
    Returns: Dict[cut_id, (ref_text, hyp_text)]
    """
    results = {}
    
    with open(path, "r", encoding="utf-8") as f:
        lines = f.readlines()
    
    i = 0
    while i < len(lines):
        line = lines[i].strip()
        
        # Tìm dòng ref
        if ":\tref=[" in line or ":\t\tref=[" in line or ": ref=[" in line:
            # Parse cut_id và ref
            if ":\tref=" in line:
                parts = line.split(":\tref=", 1)
            elif ":\t\tref=" in line:
                parts = line.split(":\t\tref=", 1)
            else:
                parts = line.split(": ref=", 1)
            
            if len(parts) == 2:
                cut_id = parts[0].strip()
                ref_list_str = parts[1].strip()
                
                # Parse list từ string
                try:
                    ref_list = ast.literal_eval(ref_list_str)
                    ref_text = " ".join(ref_list) if ref_list else ""
                except:
                    ref_text = ""
                
                # Tìm dòng hyp tiếp theo
                if i + 1 < len(lines):
                    hyp_line = lines[i + 1].strip()
                    if ":\thyp=" in hyp_line or ":\t\thyp=" in hyp_line or ": hyp=" in hyp_line:
                        if ":\thyp=" in hyp_line:
                            hyp_parts = hyp_line.split(":\thyp=", 1)
                        elif ":\t\thyp=" in hyp_line:
                            hyp_parts = hyp_line.split(":\t\thyp=", 1)
                        else:
                            hyp_parts = hyp_line.split(": hyp=", 1)
                        
                        if len(hyp_parts) == 2:
                            hyp_list_str = hyp_parts[1].strip()
                            try:
                                hyp_list = ast.literal_eval(hyp_list_str)
                                hyp_text = " ".join(hyp_list) if hyp_list else ""
                            except:
                                hyp_text = ""
                            
                            results[cut_id] = (ref_text, hyp_text)
                            i += 2
                            continue
        
        i += 1
    
    return results

def main():
    args = get_args()
    logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

    logging.info(f"Loading decode results from {args.decode_results}")
    decode_results = parse_recogs_file(args.decode_results)
    logging.info(f"Loaded {len(decode_results)} decode results.")

    logging.info(f"Loading manifest from {args.manifest_in}")
    cuts = load_manifest_lazy(args.manifest_in)
    
    filtered_cuts = []
    total_cuts = 0
    removed_cuts = 0
    matched_cuts = 0
    
    def normalize_text(text):
        """Normalize text for WER calculation."""
        if not text:
            return ""
        # Lowercase
        text = text.lower()
        # Remove punctuation
        import string
        text = text.translate(str.maketrans('', '', string.punctuation))
        # Remove extra spaces
        text = ' '.join(text.split())
        return text

    rejected_examples = []
    
    logging.info("Filtering cuts...")
    for cut in tqdm(cuts):
        total_cuts += 1
        
        if cut.id not in decode_results:
            if args.keep_unmatched:
                filtered_cuts.append(cut)
            else:
                removed_cuts += 1
            continue
        
        matched_cuts += 1
        ref_text_from_manifest = cut.supervisions[0].text if cut.supervisions else ""
        ref_text_from_decode, hyp_text = decode_results[cut.id]
        
        # Sử dụng ref từ manifest (ground truth)
        ref_text = ref_text_from_manifest
        
        if not ref_text:
            removed_cuts += 1
            continue

        # Normalize texts
        ref_normalized = normalize_text(ref_text)
        hyp_normalized = normalize_text(hyp_text)
        
        if not ref_normalized:
            removed_cuts += 1
            continue

        # Calculate WER without transformations
        try:
            wer = jiwer.wer(ref_normalized, hyp_normalized)
        except Exception as e:
            logging.warning(f"Error calculating WER for {cut.id}: {e}. Removing.")
            removed_cuts += 1
            continue

        if wer > args.wer_threshold:
            removed_cuts += 1
            if args.inspect_num > 0 and len(rejected_examples) < args.inspect_num:
                rejected_examples.append({
                    "cut_id": cut.id,
                    "wer": wer,
                    "ref": ref_text,
                    "hyp": hyp_text
                })
        else:
            filtered_cuts.append(cut)

    # Print rejected examples
    if rejected_examples:
        logging.info(f"\n{'='*60}")
        logging.info(f"TOP {len(rejected_examples)} REJECTED EXAMPLES (WER > {args.wer_threshold})")
        logging.info(f"{'='*60}")
        for ex in rejected_examples:
            logging.info(f"\n[REJECTED] Cut ID: {ex['cut_id']} (WER: {ex['wer']:.2%})")
            logging.info(f"  Ref: {ex['ref'][:100]}...")
            logging.info(f"  Hyp: {ex['hyp'][:100]}...")

    logging.info(f"\n{'='*60}")
    logging.info(f"SUMMARY")
    logging.info(f"{'='*60}")
    logging.info(f"Total cuts in manifest: {total_cuts}")
    logging.info(f"Matched with decode results: {matched_cuts}")
    logging.info(f"Removed cuts: {removed_cuts} ({removed_cuts/total_cuts*100:.2f}%)")
    logging.info(f"Remaining cuts: {len(filtered_cuts)} ({len(filtered_cuts)/total_cuts*100:.2f}%)")

    logging.info(f"Saving filtered manifest to {args.manifest_out}")
    filtered_cutset = CutSet.from_cuts(filtered_cuts)
    filtered_cutset.to_file(args.manifest_out)
    logging.info("Done.")

if __name__ == "__main__":
    main()
